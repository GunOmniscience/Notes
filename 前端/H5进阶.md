# H5进阶

## 1.获取地理信息位置

**前提：**

1. 因为地理信息位置属于敏感信息，在有的系统下无法获取

2. 定位(GPS),台式和笔记本基本都没有GPS，智能手机有GPS

   `不能通过GPS定位那么我们如何进行定位呢？，使用我们的网络进行定位，因为我们网络访问的基站是有地理信息位置的，所以我们能拿到大概的一个经纬度位置`

3. 只有在https和file协议下我们才能获取定位成功

   因为如果是在http协议下获取的话是可以通过中间人攻击或者流量拦截拦截到的
   
4. 谷歌浏览器想要访问的话需要进行翻墙，因为谷歌浏览器访问的是谷歌地图，而我们国内是访问不出去的，所以建议使用edge浏览器



**维度：**

> 经度( longitude )分东西半球各180°，所以我们经度的范围是0~180
>
> 维度( latitude )分南北半球各90°，所以我们维度的范围是0~90



**获取地理信息位置的api：**

```js
window.navwindow.navigator.geolocation.getCurrentPosition(position => {
    //获取成功的回调
},() => {
    //获取失败的回调
})
```

![1607393447452](../笔记图片(勿删)/1607393447452.png)

## 2.四行写一个服务器

1. 下载node环境

2. 在webstom中新建一个项目

3. 新建一个js文件，这里我使用server.js

4. 使用命令`npm init`导入npm包

5. 一直按回车，然后会出现一个新的.json文件将他放到你的项目中和server.js同级

6. 在webstom设置中搜索node，然后将

   ![1607479684366](../笔记图片(勿删)/1607479684366.png)

   勾上

7. 然后我们在输入`npm install express --save`下载npm，我们就会发现一个新的.json文件，将其拖到server.js同级下

8. 如果下载失败则去相对应的路径将npm-cache文件夹删除重新执行命令然后下载

9. 下载完成后在server.js中输入四行代码：

   ```js
   var express = require("express");
   
   var app = new express();
   
   app.use(express.static("./page"));
   
   app.listen(12306);//端口号尽量大于8000或者等于80,80端口是浏览器默认的端口我们如果不输入端口号则浏览器默认访问80端口，如果不是80端口我们则必须输入对应端口号
   ```

10. 在server.js的同级目录下创建一个名叫page的文件夹，express框架默认访问index.html，其他的则要在域名后加/文件名.html



**注意：**

端口号尽量大于8000或者等于80,80端口是浏览器默认的端口我们如果不输入端口号则浏览器默认访问80端口，如果不是80端口我们则必须输入对应端口号



**打开我们的服务器页面：**

**第一种：**

在webstom中运行server.js然后去浏览器输入127.0.0.1:端口号

**第二种:**

在终端中进入到server.js的目录下输入`node server.js`就可以启动我们的服务器了，然后去浏览器输入127.0.0.1:端口号，即可！



## 3.重力感应

H5新增了一个新的事件API`deviceorientation`通过这个事件我们可以捕捉到手机陀螺仪的数值

**绑定事件：**

```js
//给整个页面绑定重力感应事件
window.ondeviceorientation = function (event){
    
}
```

**注意：**

1. 陀螺仪，只有带有陀螺仪的设备才支持体感
2. 在iPhone和微信浏览器下，只有https协议的才可以触发该事件，因为它们认为这是用户隐私
3. 在windows和安卓手机下则不需要
4. 因为笔记本是没有陀螺仪的所以我们在Windows触发的该事件alpha，beta，gamma都是null，得在安卓手机

**alpha，beta，gamma各值所对应的东西：**

当手机正面朝上平方在桌面时所有的值都是0

**alpha：**

手机顶端是指北的，也就是0°，也就是说180°则是南边

指范围：0~360

**beta：**

手机短边靠桌面

当手机面朝我们慢慢向我们面前立起来，值得变化是0~90

如果手机背面朝我们慢慢向我们面前立起来，值得变化是0~-99

**gamma：**

手机长边靠桌面

当手机面朝我们慢慢向我们面前立起来，值得变化是0~90

如果手机背面朝我们慢慢向我们面前立起来，值得变化是0~-99

## 4.requestAnimationFrame

我们一般电脑帧率为60帧，平时我们使用setinterval来做动作循环执行，然后我们想要这个动作看起来顺滑一点，我们通常会将时间间隔调成1000/60，可是在浏览器的默认事件队列里，如果我们循环执行的代码过于复杂在1/60秒里执行不完他是不会执行下一次动画的，且setinterval的定时是不准确的，针对这个问题，H5为我们新出了一个requestAnimationFrame

**语法：**

```js
requestAnimationFrame(即将执行的回调函数)
```

**特点：**

1. 如果我们去循环的调用它，它会以每秒60帧的一个速率去为我们执行这个回调函数，且它的60帧是100%准确的，那它是怎么做到的呢？它使用的事件队列并不是我们的宏事件队列，而是自己的一个事件队列

   

**MDN：**

![1607739148049](../笔记图片(勿删)/1607739148049.png)

**兼容性：**

虽然现在大部分浏览器的兼容性都特别的好了，但是如果我们想要特别好的去兼容这个API的话我们可以这么去写代码：

```js
window.requestAnimationFrame = (function (){
    return window.reuqestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function (callback){
    	settimeout(callback, 1000 / 60);
    }
}())
window.cancelAnimationFrame = (function (){
    return window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||function (id){
    	clearTimeout(id);
    }
}())
```

## 5.localStorage和sessionStorage

> 我们以前在浏览器里存值都是存在cookie里的，可是存在cookie里的数据在我们每次发送请求的时候都会被带出去，这样安全性会特别的差，于是我们有没有这么一个不被带出去的可存储值在浏览器里面的东西呢？于是就有了我们额localStorage



**语法：**

```js
localStorage.key名 = value值;
```

**特点：**

1. 他存储的值会在浏览器永久保存，并不是临时存储的，当我们下次打开时它同样还在

2. 他是在相对于当前域的

   同域：相同的协议 相同的域名 相同的端口号

3. 存储的值只能是字符串，所以我们如果想要存储一个数组或者是一个对象之类的东西得通过JSON.stringify(值)将他转成字符串然后再存入，当我们想要的时候取出来直接JSON.parse(值)即可

   ![1607740925794](../笔记图片(勿删)/1607740925794.png)

   ![1607740936624](../笔记图片(勿删)/1607740936624.png)

   ![1607740973844](../笔记图片(勿删)/1607740973844.png)

4. 还有一个和localStorage一模一样的可存储值的东西：sessionStorage，可是它`存储的值是临时存储在当前域的，当我们下次打开时值就会丢失`，其余与localStorage一致

**loacalStorage的API：**

![1607741258280](../笔记图片(勿删)/1607741258280.png)

> cookie拥有大小限制，大约为6k，而localStorage和sessionStorage的大小可为6MB



## 6.history

> 我们在浏览器进行搜索的时候通常会发现他们的左上角拥有一个可前进后退的东西在增加并没有我搜一个它给我一个新的页面而是就在当前页面
>
> ![1607821435330](../笔记图片(勿删)/1607821435330.png)
>
> ![1607821453821](../笔记图片(勿删)/1607821453821.png)
>
> 那我们在做搜索的时候是否也可以使用这种减少用户操作的设计呢？

**语法：**

```js
history.pushState({想要存储的数据}, null(此处因为浏览器兼容问题通常填为null), 将url地址更改为什么)
```

**配合事件：**

```popstate```事件：当我们的活动历史条目(那个左右回页)有改变时触发，它会有一个事件参数给我们

**案例：**

![1607823119188](../笔记图片(勿删)/1607823119188.png)

![1607823161557](../笔记图片(勿删)/1607823161557.png)

![1607823230726](../笔记图片(勿删)/1607823230726.png)

我们可以利用这个值来重新渲染当前页面，因为我们的搜索页内容就是由这个值(用户搜索的关键词)来决定的

**hashchange事件：**

当我们页面的锚点(#锚点名)更改时触发事件，通常我们点击回退时页面的锚点更改然后触发该事件

![1607823485663](../笔记图片(勿删)/1607823485663.png)

![1607823470281](../笔记图片(勿删)/1607823470281.png)

**注意：**

popstate事件触发后它才触发

## 7.worker

**线程：** 传统JS时单线程的，worker是多线程的，是真的多线程，不是伪多线程

**操作：**不能操作dom，没有window对象，不能读取本地文件，可以发ajax(可是ajax本身就是异步的)，只可以用来计算

**拓展：**在worker中能否继续创建worker？理论上可以，但是没有任何一款浏览器支持

![1607826833374](../笔记图片(勿删)/1607826833374.png)