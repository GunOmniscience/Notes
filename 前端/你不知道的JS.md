### 1.JS引擎和GUI线程的互斥

​	js可以操作Dom元素，进而会影响到GUI的渲染结果，因此js引擎线程与GUI渲染线程是互斥的，也就是说当JS引擎线程处于运行的状态时，GUI渲染线程讲处于冻结状态

​	例如：

​			我们写了一个按钮，当按钮点击的时候它会惊醒一个阴影的变化

​			而我们在js代码中我们写了一个死循环，那么，我们点击这个按钮时，就不会有样式的变化了，还有就是我们**在死循环下面的代码是永远读不到的**

### 2.bind的底层原理

使用bind改变this指向，从而返回一个改变了指向的函数，所以我们通常这样写

```js
function Fn (a,b){
    console.log(this.x, a, b);
}
var x = 10;
var fn = Fn.bind(this, "a", "b");
fn();//10 a b
```

因为bind返回的是一个函数，所以我们如果在执行包含bind改变后的函数的变量时再去添加参数，它会往原先函数的后面去添加参数：

```js
function Fn (a,b){
    console.log(this.x, a, b);
}
var x = 10;
var fn = Fn.bind(this, "a");
fn("b");//10 a b
```

**被bind改变的事件的事件对象参数，是在bind参数的后面的**

如果我们new这个被bind改变的值，那么他的constructor会变成被bind改变的这个函数，并且bind里面的参数也无效了(包括改变的this)，

### 3.节流

当我们想做一个抢购的时候，如果我们碰到脚本去恶意抢购，一秒钟点击1000下的话，那我们的服务器也会崩掉，还有就是这样对其他用户的体验造成了影响，所以我们需要节流，比如一秒之内不管你点击多少次我只算你一次：

![批注 2020-04-11 170928](F:\Typora\笔记图片(勿删)\批注 2020-04-11 170928.jpg)

### 4.防抖

当我们多个事件触发的时候我们不想一下子涌进很多事件，然后就会想乱子一样，所以我们则需要用到防抖：

![批注 2020-04-11 202600](F:\Typora\笔记图片(勿删)\批注 2020-04-11 202600.jpg)

