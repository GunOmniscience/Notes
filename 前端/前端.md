### 主流浏览器及其内核

IE     trident

Firfox Gecko

GoogleChrome  Webkit/blink

Safari  Webkit

Opera    presto

### 浏览器执行页面文件

异步执行前端文件，边读边实现

### web标准

结构行为样式相分离

# H5

## 1.基本框架

```html
<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8";>
        <title></title>
    </head>
    <body>
        
    </body>
</html>
```

## 2.编码字符集

- gb2312(国家标准第2312条，中国提出，只能识别简体字符集，无法识别繁体)
- gbk(国家标准扩展版本，中国提出，能识别繁体了)
- unicode(万国码)
- utf-8(unicode升级版本是它的8位版本，还有它位的版本例如16位的。也叫万国码)

## 3.浏览器小标题

功能：更改浏览器小标题

标准写法：

```html
<title>小标题</title>
```

如何给标题添加小图标：

```html
<title>小标题</title>
<link rel="icon" href="图标地址"/>
```

## 4.<html lang="zh,en">(很值钱)(SEO)

功能：告诉搜索引擎我们的网页是关于什么内容的

en：关于英文的

zh：关于中文的

de：德语

(除了英语是English，其他的都是汉语拼英)



SEO:

```HTML
<meta content="服装" name="keywords"/> 
keywords(关键字)
<meta content="这是一个你穿了就不想拖的衣服"name="description">
description(描述)
```

 

## 5.加粗

```html
<strong></strong>
```

## 6.斜体

```html
<em></em>
```

## 7.删除线

```html
<del></del>
```

## 8.图片

```html
<img src="图片地址" alt="当图片不显示时显示的文本" title="鼠标悬浮文本" height="高度" width="宽度"/>
```

## 9.a标签

功能：

- 超链接

  ```html
  <a href="连接地址" target="窗口创建：_self(自身窗口) _blank(新建窗口)"></a>
  ```

- 锚连接

  ```html
  <a id="a"></a>
  <a href="#a">点我</a>
  <!--当点击”点我“页面就会跳转到id为a的a标签的位置-->
  ```

- 打电话

  ```html
  <a href="tel:电话号码">给成哥打电话</a>
  <!--当页面在手机运行时你点击这个"给成哥打电话"就会调用你手机的电话接口去拨打电话给成哥-->
  ```

- 发邮件

  ```html
  <a href="mailto:邮箱地址">给成哥发邮件</a>
  ```

- 协议限定符

  ```html
  <a href="javascript:js代码"></a>
  此时你点击的时候就会执行js代码
  ```

  



## 10.表格

```html
<table>
    <th></th>
    <tr>
        <td></td>
    </tr>
</table>
```

- colspan列合并
- rowspan行合并
- cellspan格边距
- cellpadding行边距

## 11.无序列表

```html
<ul>
    <li></li>
</ul>
```

type：

- disc 实心圆
- square 实心方块
- circle 圈

## 12.有序列表

```html
<ol>
    <li></li>
</ol>
```

type类型:

- 1
- A
- a
- B
- b
- i
- I

倒序:

```html
<ol reversed="reversed">
    <li></li>
</ol>
```

第几开始排（不管是什么类型你要从第几开始排就写相对应的阿拉伯数字就行了）：

```html
<ol start="2">
    <li></li>
</ol>
```



## 13.表单

```html
<form action="提交地址" method="提交方式">
    
</form>
```

`提交方式`：

- get不需要服务器，信息会显示在地址栏中，安全性差
- post需要服务器，信息不会显示在地址栏中，安全性高

**提交数据需要数据名和数据值**

## 14.input按钮

```html
<input type="按钮类型" name="属性名" id="id名" value="属性值" checked="checked"默认选项/>
```

**按钮类型**：

- text文本框

  onfocus当鼠标聚焦时      onblur当聚焦取消时

- password密码框

- submit提交按钮

- radio单选框

  name一样才是相当于一道题的样子

- checkbox复选框

  当我们使用单选框或复选框时为了我们的用户更容易的点击到按钮我们通常用

  `<label for="所包含的单选框或复选框的id名"></label>` 

- button按钮

- reset重置按钮类似于取消

- file文件领域

- hidden隐藏领域

**input还可以添加的属性**：

这个按钮的效果：

- readonly只读

- disabled禁用

- required必填

- placeholder提示

  ```html
  <input placeholder="提示语"/>
  ```

  效果和input文本框中加value一样

## 15.下拉列表

```html
<select name="">
    <option selected="selected(默认选项)" value=""></option>
</select>
```

## 16.文本域

```html
<textarea row="行" col="列"></textarea>
```

## 17.HTML编码

- &nbsp 空格
- &lt <
- &gt >
- &copy  版权标识符

## 18.换行

```html
<br/>
```

## 19.水平线

```html
<hr/>
```

## 20.label标签
绑定关系，如果我们点input，label不会触发，点label，input会触发

```html
<label for="userName">用户名</label>
<input type="text" id="userName"/>
<!-- 此时当我们点击用户名时相当于点击了文本框所以文本框会被聚焦，此时点击他们两个触发的事件是一致的，作用在于用户更好的体验，也就是当我们点击字他也会聚焦 -->
```

# CSS

### *BFC

**父子级元素垂直方向的margin会取最大的值进行移动**

BFC：不按CSS原来的渲染规则来对元素进行渲染

如何触发BFC：

​	position: absolute;

​	display:inline-block;

​	float:left/right;

​	overflow:hidden;

**根据需求选择使用**

### 三大类元素

**display可以将任何一个元素随意改变类型**

凡是带有inline或者inline-block都有文字特性(分开来写的时候会有类似于单词的分割，占4px)

行内元素/行级元素(inline)

- 不独占一行
- 不能设置宽高
- 内容决定元素所占位置



块级元素(block)

- 独占一行
- 能设置宽高



行内块/行级块元素(inline-block)

- 内容决定大小
- 可设置宽高



### 权重(256进制)

!important       Infinity

行间样式            1000

id                         100

class|属性|伪类 10

标签|伪元素         1

通配符                   0

### 选择器

##### 选择器**优先级**：

!important > 行内样式 > id > class  属性选择器 > 标签 > 通配符



##### 普通选择器：

**id选择器**

- 一个id值只能对应一个元素

html中：

```html
<p id="a">
    
</p>
```

css中:

```css
#a{
    css代码
}
```

**class选择器**

- class可以对应多个元素
- 一个元素可同时引用多个class

html中:

```html
<p class="b a">
    
</p>
```

css:

```css
.b{
    
}
.a{
    
}
```

**标签选择器**

- 所有的这种标签都会引用上这个样式

html:

```html
<p>
    
</p>
```

css:

```css
p{
    
}
```

**通配符选择器**

- 所有的**标签**都会引用到这个样式

css:

```css
*{
    
}
```

**属性选择器**

- 拥有这个属性的元素引用样式
- 还可以把值也写上[id="a"]这时候只要时拥有id属性并且值为a的元素会应用这个样式

css：

```css
[id]{
    
}
```



##### 复杂选择器：

- 浏览器从右向左找对应元素
- 当两个伪元素选择器同时指向同一个元素时，哪一个的选择器的权重值相加起来大哪一个生效，当权重一样时后面的伪元素选择器会覆盖前面的选择器的样式



1.父子选择器/派生选择器

这个父元素下面的子元素受到这个样式



```html
<p>
    <span>123</span><!--变色-->
</p>
<span>123</span><!--不变色-->
```

```css
p span{
    background-color:red;
}
```



2.直接子元素选择器

这个父元素下面的第一个子元素受到这个样式



```html
<p>
    <em>123</em><!--变色-->
    <strong>
        <em>123</em><!--不变色-->
    </strong>
</p>
```

```css
p > em{
    background-color:red;
}
```



3.并列选择器

平列条件都满足的受到这个选择器



```html
<div>1</div>
<div class="Demo1">2</div><!--它变色其他都不变色-->
<p class="Demo1">3</p>
```

可加多个特征进行并列然后提供选择

注意：当与标签选择器并列时因为识别问题标签选择器得放前边

```css
div.Demo1{
    background-color:red;
}
```



4.分组选择器

全部都受到样式



```html
<em>1</em>
<p>1</p>
<span>1</span>
<!--都变色-->
```

```css
em,
p,
span{
    background-color:red;
}
```

5.相邻选择器

```html
<p>
    
</p>
<b></b>
<div>
</div>
<b></b>
```



```css
div + b{
    和div相邻的b标签受应用
}
```



##### 伪类选择器:

```css
p:hover{
    
}
```

声明顺序：link - visited - hover - active

hover 鼠标悬停

link 正常浏览的样式

visited 点击过的样式

active 点击未放时的样式



##### 伪元素选择器：

任何一个标签再开始的时候就都自带了两个伪元素，如果我们不把他选出来我们是看不到的。

一般类似于：：加before或者after的就是伪元素选择器

它可以设置样式也可以添加内容。

**伪元素写的内容再页面上是不能被选中的。**

**属性content是专门再伪元素里面有的，别的元素不好使，专门用来加内容。**

**伪元素天生是inline，如果想要加样式或者宽高啥的，得把它的display设置成inline-block。注意：加上content伪元素的样式才能生效，通常把content设成“”**

```html
<span>很帅</span>
```

```css
span::before{
    content:"成哥";
}
span::after{
    content:"，是的的确是这样";
}
```

<img src="F:\Typora\笔记图片(勿删)\批注 2020-03-14 143704.jpg" alt="批注 2020-03-14 143704" style="zoom: 67%;" />



### 引入CSS

**引入外部样式**

```html
<link rel="stylesheet" href="css文件地址"/>
```

**引入内部样式**

```html
<style type="text/css">
    css代码
</style>
```

**行间样式**

写在标签内部的style属性中：

```html
<p style="">
    
</p>
```



### 盒子出现滚动条

```CSS
overflow:scroll;/overflow:auto<!--用auto如果内容没有超过宽度则不会有横向滚动条就不用那么麻烦-->
```

消除横向滚动条：

```CSS
p::-webkit-scrollbar{
    width
    height将height设置为0
}
```

设置滚动条样式：

```CSS
p::-webkit-scrollbar-thumb{
	background 设置滚动条颜色
	box-radio 设置滚动条圆角
}
```

### 浮动

float当我们设置左边那么我们的盒子就向左边排列
右边就向右边排列

### 去掉文本框点击时蓝线

```CSS
outline:0;
```

### 一般网页样式框架

```css
body{
    width:1240px;
    margin:0px auto;
}
*{
    margin: 0;
    padding: 0;
}
```



### 单位

px：相对于一英寸能容下多少个像素点

em：em = em*当前元素的像素(默认值为16px) 将字体的高度变成宽度来计算然后缩进





## 1.水平对齐

```css
alight=""
```

- Center 居中
- Left 居左
- Right 居右

## 2.垂直对齐

```css
vertical-alight=""
valight=""
```

- Middle垂直居中
- Top垂直居上
- Bottom垂直居下

## 3.背景颜色

```css
background-color=""
```

## 4.渐变色

```css
p{
     background: linear-gradient(to right/bottom,red,green,yellow);
}
```

## 5.字体阴影

```css
p{
    text-shadow: x y 模糊值
}
```

## 6.行高和垂直对齐的小关系

当我们的行高和这个标签的高度一样我们则可以垂直对齐

line-height：

如果设置相对值比如%，em，那么它的实际值就是这个值乘以16的积

## 7.字体

font-family

## 8.字体大小

**默认值：16px**

**实际设置的是字体的高**

font-size

## 9.字体颜色

**土鳖式(单词)**

**颜色代码#FF4400**

R          G             B

00-ff   00-ff      00-ff

光的三原色组合在一起为白色

如果两个字母或数字一样的话可以简写

**颜色函数rgb(255,255,255)**

color

## 10.背景图片

```css
p{
    background-image:url(图片地址);
}
```

设置图片大小：

```css
background-size:x轴图片像素 y轴图片像素;
```

如果想要和容器的宽高相同的话，则x，y值和容器相同

通常设置成100%100%

## 11.平铺属性

```css
p{
    background-repeat: repeat-x/repeat-y/no-repeat;
}
```

## 12.背景图片准确位置

background-position: x y;

background-position-x:;

background-position-y:;

还可以填类似于left top(坐上)

如果想要居中显示，填center center

## 13.图片完全填充此空间

background-size:cover;

## 14.列表样式

ul的东西

```css
ul{
    list-style:none;
}
```

## 15.浮动

```css
float:left;/*从左边开始向右*/
```

## 16.字体加粗

```CSS
font-weight:bold;
```

## 18.css事件

link 正常浏览

visited 点击过的

hover 悬停

active 单击未放

cursor 鼠标悬停指针样式

依优先顺序排写

## 19.字体风格

font-style

italic斜体

## 20.边框

```css
border:粗细 线的样式 线的颜色
```

粗细：

上右下左



线的样式：

dotted点状虚线

dashed虚线

solid实线



线的颜色：

transparent：透明色



边框圆角

```css
border-radius:上右下左/全部;
```



小技巧：当我们所有颜色都满的时候其实我们的边框颜色的上右下左各边占的是一个**三角形**，可以用来做微信对话框(注意：利用透明值)



## 21.文本水平对齐

```css
 text-alight:left(默认值);
```

可以配合line-height实现上下左右都居中



## 22.文本头缩进

单位：em（一个中文)

```css
text-indent:2em;
```



## 23.文本修饰符

```css
text-decoration:none;
```

underline下划线

overline上划线

none无



## 24.指针样式

```css
cursor:pointer;
```

pointer 和a标签一样的小手

help 问号指针

move 十字架一样的指针



## 25.定位

### 	25.1 absolute绝对定位：

​			当一个元素的定位值为绝对定位，那么这个元素会变成**层模型**，也就是它原先的位置会被别人占据，他**在别人的上面**

​			如果他的父级元素有定位那么**相对于父级元素进行定位**，如果他的父级没有定位那么**相对于浏览器进行定位**

### 	25.2 relative相对定位：

​			保留原来位置进行定位，和绝对定位一样可以在别的元素上方，和灵魂出窍一样

### 	25.3 fixed固定定位

​			和绝对定位一样

### 	25.4 z-index层级

​			z-index：值；

​			谁的值高谁在上面

### *25.5 sticky定位

​			position:sticky

​			**相对于最近的有滚动特性的父级进行定位**，浏览器内容不够显示它会自动有纵向滚动条所以它就会相对于浏览器这个有纵向滚动条的视口进行定位，**他原有的位置不会被占据**

​			**用来做当前一般网页移动到下面时的上面出现的栏**

​			技巧：可以实现不在最顶部做滚到中间时的顶栏效果，我们计算window的值，然后用jq给他添加class样式，然后抹除即可

## 26.透明度

opacity：0.5；

值的范围：0~1

## 27.溢出隐藏

```css
overflow:hidden;
```

## 28.浮动

```css
float:left/right;
```

可以使块级元素按照float的设置来排列，如果它右边够占一个元素就占，否则换行来排列

通常用来设置`li`

**注意：**

浮动元素产生了浮动流：

​	所有产生了浮动流的元素，块级元素看不到，所以就会像绝对定位一样原来的位置被别人代替

​	产生了bfc的元素和文本类属性元素(inline)以及文本都能看到浮动元素

## 29.清除浮动

```css
clear:both;
```

值为：left/right/both

通常只填both

**它只有加在块级元素的样式里边才会有效果**

## 30.背景透明

```css
backface-visibility:visible;/*背景透明，内容不透明*/
backface-visibility:hidden;/*背景不透明，内容不透明*/
```

## 31.文本类元素对齐

因为文本类元素它会进行底对齐，然后如果你想调整，那么就用这个属性

```css
vertical-align:正值或者负值;
```

## 32.列表样式

```css
list-style:none;/*一般用于去除ul前面的小黑点*/
```



# **JS**

### 		JS为解释性语言

### 		JS为单线程(js引擎是单线程)

### 		*JS执行特点

​					js在执行时可以用很多个script标签写script代码，**他们的变量都是公用的(因为程序从上往下执行，执行过的东西它都记得)**，不过**如果有一个script标签里面的js代码错了，不会影响其他script标签里面的代码执行**。

## 1:JavaScript引入、变量、值、类型、运算符.

**1.引入**:

​                     在<head></head>或者<body></body>中都可以写入JavaScript代码，但前提是        **JavaScript代码要写在<script type="text/javascript"></script>标签中(页面级js)**.

​                     **或者使用外部js代码，JavaScript代码:引入外部JavaScript代码只需要在script标签中添加一个src引入属性并在引入中写上所对应的JavaScript代码文件名即可**。如**果又在html中写JavaScript代码又引入JavaScript，则只使用外部的JavaScript代码，而html中的JavaScript代码则会被覆盖掉，并且无效。**

**2.数据类型**:   

**undefined(未定义类型) null(空类型) number(数值类型) String(字符串类型）boolean (布尔类型）**

​                     **原始型**: *int/double/String/boolean/undefined/null*

​                     不管什么数据类型因为JavaScript也是一种叫解释性语言所以只用且只有一个var类型。

​                      你var的值是什么他就是什么类型的。其实可以把var当做就是一个字符串。

​                      注:

​                           一个变量声明了但是没赋值那打印出来的就是undefined，意思是没有值或者没有东西。

​                           给一个变量赋null值是因为不想它显示undefined所以就拿一个null(空)值来代替它。

​                      

​                     **引用型**: *array(数组)/对象/方法*

​                                 **数组**:

**JavaScript中的数组里可写各种值**: **var i = [1,2,3,false,"HelloWorld"];** JavaScript中如何**向数组中添加值**: **i.push(6);** //加入的值"6"因为数组i没有固定长度所 以加入的6则会使数组i的长度增加了1，所以6这个值在HelloWorld的后面。 

​           

**3.引用值与原始值的相等**:

 *假设i = n; 如果n为引用值那么copy的是它的**地址**，当n的值改变那么   i 的值也会改变；如果n为原始值那么copy的只是它这个**值**，**当n再次变化时i不会随着n的改变而改变。***

​          ***注**：假设var i = [1 , 2];   此时i指向【1，2】这个地址，而当i = 【1，3】时i此时指向的是新开辟的【1，3】。而以前的【1，2】则变成了无指向的垃圾内存;*   

​          *在JavaScript中"+"号两端**只要有一个字符串则这个+都是起连接作用**。例:①var i = "a" + "b",  i = ab;  ②var i  = "a" + 1;    i = a1;*

## 2:运算符/循环.

**4.JavaScript中的换行**:

```js
document.write(" ");
```



**5.JavaScript中NaN不等于任何东西，包括自己。**

**6.undefined，null，“”，0，false转化为布尔值都是false；其他的值转化为布尔值都为true。**

**7.**

例:var i = 1 && 2 + 2;

![img](F:\有道云笔记\qq31BDEC0D05E5A1626E555CD1BA33D617\eb0ffb42c1df4cfb9ada7c8725abb283\捕获.png)

注:全真才为真！例如  var i = 1 && 0; 此时返回的值依然是false.

*&&运算符碰到假就停*

*||运算符碰到真就停*

*！运算符写在值前面的作用是将值变成布尔取反        例如:**var i = !123;     则答案为false.***

8.弹出一个有提示可输入的窗口让用户进行输入，并用一个变量来接受用户输入的值:

```js
var i = parseInt(window.prompt("提示信息"));
/*
弹出警告信息
*/ 点击后       可不写
onclick = "JavaScript:alert('欢迎你')"  
//写在"input"标签中的;并且只能用单引号.(在JavaScript中可用双引号!) alert(''); 
/*
对话框(可输入值) 
*/ 
prompt()  //在input标签中可以用一个值来接收你输入的值. 
```

**注:在input标签中只能使用单引号，因:使用双引号则会使JavaScript的引号相冲突并报错。**

**9..typeof:***可用来判断一个值或变量究竟属于哪种数据类型.*

​                     返回类型:

​                                     undefined--当变量是undefined类型是；

​                                     number--当变量是number类型时；

​                                     String--当变量是String类型时；

​                                     boolean--当变量是boolean类型时；

​                                     **object--当变量是null类型，或者变量是一种引用类型时，如:对象，函数.**

**用法**:打开浏览器，按F12，选择console。

**10.理论知识:**

​                     **1.**浏览器验证在客户端验证;

+++

## 自己

##     3:函数:   

​      不管有参无参都要写括号

​              **获取当前时间:   var 变量名 = new Date;**

​               **getYear()年    getDate()日   getMonth()月**

###               1.语法:      

​							    

```js
 function  函数名  (参数1,参数2,参数3...)

                             		{

​                                                 JavaScript语句;

​                                    }
```



###               **2.return:**

​                          return用来规定函数中返回的值，需要返回某个值的函数必须使用return语句;

###               **3.调用函数:**

​                          **事件名 = "函数名()";**

###               **4.事件:**

​                      onclick 点击(当被点击时触发);

​                      在form后添加事件onsubmit，则可以使表单数据在提交之前调用这个函数进行判断；

​                 提交函数提交表单:       表单对象.submit();

​                 根据表单验证的结果决定是否提交表单:    <form onsubmiCt = "return 表单验证函数()">

​                 如果用JavaScript提交: if(表单验证函数()){

​                                                      表单对象.submit();   注:若用这个方法提交表单，则不需要在<form>标签的onsubmit事件中调用验证函数。

###           **11.表单信息获取:**

​                       返回字符串的长度:

​                            字符串对象.length;               例: var str = "this is JavaScript";

​                                                                               var strlength = str.length;    则返回str的长度为18.

​                       获取表单值:

​                                var 变量名 = document.getElementByld(”id名");

​                           例：<input type="text" id=''user"/>

​                                   在script中想要拿到id为user的值: user.value;

​                       如何让一个图片具有提交表单的效果:

​                              

```js
<img src="图片地址" onclick = "if(函数名()) 表单名.submit()"/>  
```

**12.String对象的常用方法:**

​                      **index的范围是0~字符串对象.length-1；**

​                      toLowerCase()    把字符串转化为小写;

​                      toUpperCase()    把字符串转化为大写;

​                      charAt(index)      返回指定位置的字符;

​                      indexOf(字符串,index)    查找某个指定的字符串值在字符串中首次出现的位置;

​                      **(如果没有则返回-1)**

​                      substring(index1,index2)   返回位于指定索引 index1 和 index2之间的字符串,并且**包括                   索引 index1 对应的字符,不包括索引 index2 对应的字符;     如果只输入一个数字，则是包括这个索引之后的字符串；**

​                      **语法:**

​                            **字符串对象.方法名();**

​          **高级触发事项:**

​                       表单id名.focus();        自动选中所对应的表单id名的框；

​                       表单名.select():          自动将所对应的表单id名框中的内容全选中;

  

### **13. window对象的常用事件:**

都

**必               onload              一个页面或一幅图像完成加载**

**需**               **onmouseover  鼠标移到某个元素之上**

**添**               **onclick             单击某个对象**

**加               onkeydown      某个键盘按键被按下**

**w**               **onchange         域的内容被改变**

 i       14.确认或取消对话框: window.confirm();               如果"确认"则confirm返回true;"取消"则返false;

n       15.打开或关闭一个窗口:   window.close()  关闭一个窗口;                   填写宽高等等...

d                                                 window.open("弹出窗口的url",”窗口名称“,”窗口特征“)  打开一个窗口;

o             窗口特征(用=号):   height、width        高宽

w                                                           left、top       窗口的x坐标,y坐标,以像素计算;

.                                                            toolbar = yes(1)/no(0);    是否显示浏览器的工具栏

​                                                             scrollbars = yes(1)/no(0);  是否显示滚动条

​                                                             location = yes(1)/no(0);    是否显示地址栏

​                                                             status = yes(1)/no(0);   是否显示状态栏

​                                                             menubar = yes(1)/no(0);  是否显示菜单栏

​                                                             resizable = yes(1)/no(0); 是否显示可调节尺寸

​                                                             titlebar = yes(1)/no(0);    是否显示标题栏

​                                                             fullscreen = yes(1)/no(0);是否使用全屏模式显示浏览器 默认no

​               

​          **16.Date对象:**

​                 **方法组:**

​                       **setXxx           这些方法用于设置时间和日期值**

​                       **getXxx           这些方法用于获取时间和日期值**

​                 **get分组的方法:**

​                       **getDate() 返回Date对象的一个月中的每一天，其值介于1~31；**

​                       **getDay()  返回Date对象的星期中的每一天，其值介于0~6；**

​                       **getHours() 返回Date对象的小时数，其值介于0~23；**

​                       **getMinutes() 返回Date对象的分钟数,其值介于0~59；**

​                       **getSeconds() 返回Date对象的秒速，其值介于0~59；**

​                       **getMonth() 返回Date对象的月份，其值介于0~11；(通常以值加1来显示)**

​                       **getFullYear() 返回Date对象的年份，其值为4位整数；**

​                       **getTime() 返回**1970年1月1日到今天的毫秒数;       

​                **转化日期函数:**

​                       读取Date值的变量名**.**toDateString() 把Date对象的日期部分转换为字符串,并返回结果;

​                                             变量名.toTimeString() 把Date对象的时间部分转换为字符串,并返回结果;

​                                             变量名.toLocaleString() 把日期和时间转换为本地格式的字符串；

​                                             变量名.toLocaleDateString() 根据本地时间把Date对象的日期部分转换为                                     

​                                             字符串，并返回结果；

​                                             变量名.toLocaleTimeString() 根据本地时间把Date对象的时间部分转换为

​                                             字符串，并返回结果；

​              **定时:**

​                      **setTimeout**    

​       **17.打印在控制台:**

​                   **console.log()**

​                   **arguments实参列表:在函数中赋给函数是所有值都在这个实参列表中,想要查看赋了多少值则可使用console.log(argument);则可将实参列表打印在控制台中.控制台中可将实参列表打开查看**

+++

## 成哥



### 	1.输出语句(会打印到页面中)：

```js
document.write(变量名);//就和输出语句是一个道理
```

### 	2.定义变量

​		js中定义变量只有一个var，他是通过值来判断数据类型的

```js
var 变量名 = 值;
```

​			**如果有多个变量一起那么得分行**

```js
var a = 1,
    b = 2,
    c = 3;
//或者
var a,
    b,
    c = 1;
```

​		**命名规则**

​			只能$,_,字母开头

​			变量名可以包含$,_,字母,数字

​			会区分大小写

​			不能用保留字做变量名

### 	3.数据类型

​			**基本类型(栈内存)**

​					Number(数字)，String(字符串)，Boolean(布尔)，undefined(没有填值)，null

​				undefined可以当作值来赋

​			**引用类型(堆内存)**

​					object，function

​				**数组**	

​					js的数组中可以填各种数据类型的值			

```js
var arr = [1,"a",null];
```

​					*js的数组中如果想要往原来的堆内存里面加东西嘚用push(要加的值)函数

```js
var arr = [1,2];
var arr1 = arr;
arr.push(3);
document.write(arr1);//结果为1,2,3
```

​					而如果直接写一个数组值给arr的话这样在js中则使**开辟了一个新的堆内存**，然后把地址给到了这个arr

```js
var arr = [1,2];
var arr1 = arr;
arr = [1,2,3];
document.write(arr1);//结果为1,2,3
```

​			**凡是是数字可是又不知道怎么表示出来的数都会显示NaN，它也是一个数字类型的值，意思是非数**，例如0/0

```js
document.write(0 / 0);//NaN
```

​			**如果1除以0他是一个无穷大的数字那么它会返回Infinity**

```js
document.write(1 / 0);//Infinity
//如果是-1的话结果为-Infinity
//*Infinity + 1 > Infinity
```

### 4.运算符		js返回的不是true/false而是比较的值，”非“运算符的结果为true/false并不是值

```js
document.write("10" > "8");//字符串10不是十而是一，零它拿1，0的ASCAII的码去和8比，所以为false
```

​		**只有NaN和自己比较不相等，其他都相等，NaN也不等于任何东西**

​		**js中的与，或，非运算符**

​		与(&&)

​			undefined， null，NaN，""，0，flase ==> 转化为Boolean都是false

​			其他都是真

​			js中的返回不会是true或者false，它会返回值也就是我们比什么它返回什么

​			如果第一个错了直接返回第一个，第一个对了，看第二个然后返回第二个

​			**我们可以拿与运算符当if else用(短路语)**

```js
2 > 1 && document.write('杰哥很帅');//如果2 > 1 那么 输出 杰哥很帅
```

​			**公司里面因为要通过Ajax从后断传数据过来然后执行一个语句，而如果我们执行这个语句它为空的话那么我们整个程序都会出错，所以我们为了判断这个东西是否有问题我们通常这么写，这就是为什么叫短路语句**

```js
var value = Ajax传过来的值;
value && fn(value)...//这样我们如果value出现问题我们最多就是没有显示而不会影响整个js程序
```

​		或(||)			

```js
var e = function (e){
    //在IE浏览器里面想取e这个值
   	var value = window.value;//这样才能取到
    //在非IE里面想取e这个值
    var value = e;
    //那么我们想要有一个兼容也就是不管是在哪个浏览器我们都能取到
    var value = window.value || var value = e;//这样我们就形成了一种兼容
}
```

​		非(!)

​			**js中的！是先把值变成Boolean值然后取反,也就是说”非“运算符的结果为true/false并不是值**

### 5.条件语句(if else ...)

#### 		switch语句：

​				js中的switch case可以放任何类型的值进行比对，然后只要相等就执行就完事了			

```js
switch(n){
    case '1':
        break;
    case 2:
        break;
    case true:
        break;
}
```

### 6.数组

​			语法：

```js
var arr = [1,2,undefined,NaN];
```

​			js中的数组长度也是arr.lenght

### 7.对象

​			里面可以放属性和方法

​			必须写逗号分开

​			语法：

```js
var jie = {
    //属性名 ： 属性值,
    name : "郑文杰",
    age : 18,
}
```

​			取值：

```js
console.log(jie.name);
```

​			赋值：

```js
jie.name = "郑";
```

### 8.获取类型typeof(),和C#一样

​			基本数据类型：number string Boolean 

​			引用数据类型：object  ：数组、对象、**null（在以前null作为对象的占位符，所以它是引用类型object）**

​			undefined function

​			typeof返回的值都是string类型的

​			typeof也可以这么写：typeof 123  number

### 9.类型转换

​			不发生类型转化：

​				===

​				!==

​			隐式类型转化：

​						isNaN() 给一个值判断它是否是NaN true/false 它其实里面隐式的调用了number()然后拿number后的值于NaN进行比较 比如"abc"-->NaN-->true

​						++/-- /+/-/%// 自增自减 正负 摩尔 除

​								它会先将你的值给number()转化一下然后再进行自增自减

​								例：

​										1 * "1"-->1 * 1 --> 1

​						&& / || / !

​								它会给你调用Boolean()方法

​						== / !=

​								它会先将两个数字都变成number类型 它会隐式给你调用Boolean() 

​						> / < / <= / >=

​								看和谁比较它比较完时会调用Boolean   比较时会转化成number()

![微信图片_20200321230732](F:\Typora\笔记图片(勿删)\微信图片_20200321230732.png)

​			显示类型转化：

​			**Number(mix)**

```js
var value = number('123');
```

​				null --> 0
​				undefined --> NaN
​				true --> 1
​				false --> 0
​				看起来不是数字的也就是转完不是数字的都是NaN，NaN也是数字类型

​			**parseInt(string,radix)**

​					进制范围：2~36

```js
var value = parseInt(123.5);//123
var value = parseInt(10, 2);//以10进制为基底转化为其他进制 1010
var value = parseInt('abc123');//NaN
var value = parseInt('123abc');//123
```

​			**parseFloat(string)**

```js
var value = parseFloat('123.2.3');//只有第一个小数点后面的数返回，第二个小数点不是数字它就停止了
var value = parseFloat('..123');//NaN
```

​			**toString(radix)** 通过.的方式调用它 

​				undefined，null不能调用调用toString()

```js
var a = 10;
var b = a.toString(2);//以设置的进制为基底转化为10进制 '2'
```

​			**String(mix)**

```js
var a = String(undefined);//'undefined' 任何值都返回它本身
```

​			**Boolean()**

​				null-->false

​				undefined-->false

​				""-->false

​				0-->false

​				NaN-->false

​			**toFixed(num)**

num： 必需。规定小数的位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实现可以支持更大的数值范围。如果省略了该参数，将用 0 代替。 

返回值类型：string

```js
var a = 6.5555.toFixed(3)//6.556 四舍五入保留位
var a = 6.022e2//科学计数法相当于6.022*100
```

### 10.函数

**函数语法：**

```js
//第一种方式 命名函数  函数声明
function 函数名(参数列表){ //在js里面不用写什么var不然错了，直接写a, b, c;并且它的参数定义了3个它可以不传3个或者传更多的值，不过它只会有与其对应的值接收，其他多出来的实参会被放在arguments数组里，我们可以打印它，例如console.log(arguments),可以获取它的长度，也可以遍历，如果形参多了我们也可以访问到它的长度：函数名.lenght
    执行体
    //有一个隐藏的return;
}
//第二种方式 匿名函数表达式 通常用这个
var test = function (){//此时它的函数的名字为test
    执行体
}

var test = function abc(){//它会把名字忽略你访问不到，如果拿函数名字执行它会报错，只能test
    document.write('a');
}//他是一个表达式，它既然成了表达式它就不能成为函数体了，它打印test出来就是function abc(){document.write('a');}
```

如果没有执行体那么直接把函数体返回

**调用函数：**

```js
函数名();//可传任何类型的值
```

**Console：**

​	它也能往页面里面生成东西

​	它相当于在页面的最下面的一个scrip标签

**实参列表：**

​	arguments

​	形参和arguments里面的值是两个变量，不过因为系统里有映射规则所以我们的形参和arguments不管谁变他们两个的值都会跟着变，不过得是相对应的实参和形参才行

**小案例：**

我们给任意位数求和：

那么我们就不用定义参数列表

```js
var test = function (){
    var result = 0;
    for(var i = 0; i < arguments.lenght; i++){
        result += arguments[i];
    }
    console.log(result);
}

test(1,2,3,4,58,9...);
```

**函数嵌套：**

不管函数嵌套多少层只要是在函数里面的变量都是可以访问的，越里面权限越高

![批注 2020-03-19 173805](F:\Typora\笔记图片(勿删)\批注 2020-03-19 173805.jpg)

函数里面的不能被外面的访问这是局部变量

### 11.递归

1.想规律/公式

2.找出口/约束

### 12.预编译

JS运行三部：

​		1.语法分析：系统会通篇扫描看看有没有低级错误

​		2.预编译：

​				函数声明 整体提升：只要你声明了一个函数，它就会**把函数(包括里面的内容，整体)提到JS代码的最前面**，所以你不管再函数的上面调用它还是在下面调用它，其实你都是在它下面调用的它

​				变量   声明提升：如果你声明了一个变量并赋了初始值，那么只有声明提升了，不管你有没有赋初始值，只要你**定义了这个变量它的声明就提升**，所以如果你要**在一个变量的上面去访问或者使用它的话是能调用到的**，不过**值是undefined**

​				预编译：

​							**前奏**：

​										1.imply global 暗示全局变量：即任何变量，如果变量**未经声明就赋值，此变量就为全局对象所有**       

​												window：全局对象					

```js
a = 10;
//相当于：
window = {
    a : 10,
}
//在访问的时候我们都能访问
console.log(a);
console.log(window.a);
或者在控制台里面打window.a也可以

function test(){
    var a = b = 123;
    //把123赋给未声明的b，然后在把b赋给在test里面声明了的a。
}
console.log(a);//undefined;
//变量，声明提升
cnosole.log(b);//123
//任何未经声明就赋值的变量都属于window这个全局对象
```

​									2.**一切声明的全局*变量***它全是window的属性

​											window就是全局的域：其实我们初始化了全局变量，**我们拿全局变量去用的时候是去window里面取的**             ***window就是全局***

```js
var a = 10;
也相当于：
window = {
    a : 10,
}

//在全局上面访问a
console.log(a); //访问的其实是：console.log(window.a);
```

​				**预编译四部曲：**  

​					**函数体里面的预编译**： 函数预编译在函数执行的前一刻    对没有定义的变量无从下手 ，它会属于window/全局

​								1.创建AO(Activation Object活跃对象)对象：

​													AO:执行期上下文

​													AO = {

​													}

​								2.找形参和变量声明，将变量和形参名作为AO属性名，值为：undefined

​								3.将实参值和形参统一

​								4.在函数体里面找函数声明，值赋予函数体

1.创建ao@

2.声明形参和变量
3.形参，实参相统一
4.声明函数

<img src="F:\Typora\笔记图片(勿删)\题.png" alt="题" style="zoom:200%;" />

​						4以后的小圆圈都是4，画错了而已

​		3.解释性执行：解释一行执行一行 (其实就是预编译的第四部)

​	***如果AO里面有一个变量是没有定义的，那么它会去找GO的找到GO的直接拿过来使用或者打印***

​					**全局里面的预编译**： 全局预编译在JS执行的前一刻

​								1.创建GO(Global Object全局对象)对象：   ***GO === window***

​													GO:执行期上下文

​													GO = {

​													}

​								2.找形参和变量声明，将变量和形参名作为GO属性名，值为：undefined

​								4.在函数体里面找函数声明，值赋予函数体

1.创建GO
3.形参，实参相统一
4.声明函数

***现在在if里面定义一个函数语法是无法通过的***

### 13.作用域

![批注 2020-03-21 100200](F:\Typora\笔记图片(勿删)\批注 2020-03-21 100200.jpg)

![批注 2020-03-21 100431](F:\Typora\笔记图片(勿删)\批注 2020-03-21 100431.jpg)

![批注 2020-03-21 100531](F:\Typora\笔记图片(勿删)\批注 2020-03-21 100531.jpg)

![批注 2020-03-21 100833](F:\Typora\笔记图片(勿删)\批注 2020-03-21 100833.jpg)

![批注 2020-03-21 100938](F:\Typora\笔记图片(勿删)\批注 2020-03-21 100938.jpg)



***AO对象在执行一个函数的时候创建，执行完，销毁，再执行再创建，每次调用函数创建的AO(执行期上下文)都是独一无二的，其他的什么AO，GO，和它上面的AO，GO是同一个东西，因为只有函数在执行的时候才创建AO对象，所以它前面拿着的父级AO是和父级AO是同一个(包括GO)，它自己的才是它自己的，所以如果它改变了父级AO里面的值，那么父级AO里面的值就被自己的儿子给改变了，父级AO访问的值就是子级改变后的值了***

[[scope]]：作用域

![批注 2020-03-21 103156](F:\Typora\笔记图片(勿删)\批注 2020-03-21 103156.jpg)

![批注 2020-03-21 103140](F:\Typora\笔记图片(勿删)\批注 2020-03-21 103140.jpg)

例：

![批注 2020-03-21 110059](F:\Typora\笔记图片(勿删)\批注 2020-03-21 110059.jpg)

![批注 2020-03-21 110037](F:\Typora\笔记图片(勿删)\批注 2020-03-21 110037.jpg)

### 14.闭包

作用：封装函数，元素私有化

多个函数嵌套，将里面的函数返回到全局就是闭包

当内部函数被保存到外部时，将会生成闭包，闭包会导致原有作用域链不是释放，造成内存泄漏。

### 15.立即执行函数

无需调用，自动执行，执行完即被释放，其他的和正常函数一样,包括执行期上下文

```js
(function (){//变量名可写可不写
    var a = 123;
    var b = 234;
    console.log(a + b);
}());//这个括号里面可以填实参，传给形参
//执行符号写在外面分号的里面也可以，不过W3C推荐使用上面这种
(function (){
    var a = 123;
    var b = 234;
    console.log(a + b);
})();
```

立即执行函数通常除了用来改变页面样式的不用返回值以外，其他的通常都拿一个变量接收返回值

```js
var num = (function (a, b){//变量名可写可不写
    console.log(a + b);
    return (a+b);
}(123, 234));//这个括号里面可以填实参，传给形参
```

-------↑**()这个是执行符号**，*只有***函数表达式才能被执行符号执行**，函数声明只能被函数名+执行符号执行，如果**函数声明后面加执行符号的话是报错的**，**被执行符号执行的表达式会自动忽略名字**，当这个**函数表达式执行完num就不在代表一个函数体(也就是这个函数被释放了，永久的释放了)**，而是**undefined**，可是这里他最后把a+b的值丢出来给num了，所以他的最终结果为a+b的值

在函数声明前面加上+号它就变成表达式了，它就可以被执行符号执行了

```js
+ function (){
  console.log('a');  
}();
```

表达式： = ... 这个叫表达式，表达式后面是;，=前面的那个叫声明，或者是数学符号的也可以把函数声明变成表达式，例如：+ - (),&& || ！... 逻辑运算符除了！都要在前面加条件

笔试题：

​		function test(a, b, c, d){

​				console.log(a + b + c + d);

} （1，2，3，4);

弱类型语言会能不报错就不报错，所以你这样写他看到逗号运算符它就在想这是不是这样写的：

function test(a, b, c, d){

​				console.log(a + b + c + d);

} 





（1，2，3，4); //这样子写没有意义 就像数学里面 (1) + 2 = 3一样(加不加也一样)

所以它就不给你报错了，可以也**执行不了**

#### 逗号运算符

```js
var a = (1 - 1, 1 + 1);//将后面的结果返回  2
```



### 16.对象

当一个变量没有的话它会报错，当一个对象没有的时候它会返回undefined，不会报错

js的对象创建好了还可以进行更改，而其他语言的对象创建了只能就是那个类写好的样子改不了

#### 	16.1 this关键字

​		**1.函数预编译过程this --> window**

​		**2.全局作用域里this --> window**

​		**3.call/apply 可以改变函数运行时this指向**

​		**4.obj.func(); func()里面的this指向obj**![批注 2020-03-25 165954](F:\Typora\笔记图片(勿删)\批注 2020-03-25 165954.jpg)

​		它和Java中的this一样，代表自己/谁调用它

​		默认指向window

​		如果有call()则指向call()里面的值

#### 	16.2 删除属性

​		delete 属性名;

#### 	16.3创建对象

​		它两没有任何区别

​		1.var obj = {}

​		2.构造函数

​			js系统中有一个object这个构造函数和Java里的一样

​			var obj = new object();

#### 	16.4构造函数

​		构造函数的命名：使用大驼峰式命名规则   TheFirstName

写法：	(结合Java来思考)

<img src="F:\Typora\笔记图片(勿删)\批注 2020-03-22 221347.jpg" alt="批注 2020-03-22 221347" style="zoom:80%;" />

​		**构造函数执行原理：**

​					只有在有new关键字的时候执行这些步骤

​					只要你new了你可以自己写一个显示的return 对象，不过你不可以返回别的数据类型

![批注 2020-03-23 152752](F:\Typora\笔记图片(勿删)\批注 2020-03-23 152752.jpg)

​			1.它会在前面隐式的创建一个var this 对象

​			2.将你写的属性加到对象里边

​			3.return this;然后你等于这个对象他就是这个对象了

### 17.包装类

​	new String();

​	new Number();

​	new Boolean();

​	new Array();

​	new Function();

​	原始值中的undefined，null是不行有的

​	原始值不能有属性和方法的，加了和没加一样

​	而对象类型的原始值是可以有属性和方法的

​	原始值类型直接加属性或方法js会自动帮你变成 包装类().属性/方法 = 。。。，在最后它会自行销毁执行delete，所以原始值类型加属性和方法跟没加一样

数字对象

```js
var a = new Number(1);//等同于 var a = 1;
a.name = "num";
console.log(a.name);
//"num"
```

数字:

```js
var a = 1;
a.name = "num";
//原始类型是不可以有属性和方法的，系统不忍心给他报错，就帮他写成了new Number(1).name = "num"; 执行完它就delete了
console.log(a.name);//此时它系统又执行了一次上面一样的操作，结果一样delete了，所以就没有了，就是undefined
//对象没有属性返回的是undefined，不会报错
```

**我们访问字符串.length的底层原理：**

```js
var str = "abc";
var len = str.length;
//底层为:var len = new String("abc").length; 然后字符串包装类自带有length属性和数组一样
```

### 18.原型(prototype)

定义：**原型是function对象的一个属性**，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以***继承*该原型的*属性*和*方法***。**原型也是对象**。

> 它的子类也可以重写父类的属性或方法
>
> delete子类继承父类过来的属性或方法，无法删除，它一样还会继承父类的继承过来，其实关键是它自身没有那个属性

应用场景：

> 减少代码冗余，将相同的代码提到父类里继承过来，自己保留会被改变的即可

用法：

```js
Person.prototype.LastName = "郑";
function Person(){
    
}
var person = new Person();
console.log(person);//打印函数体
console.log(person.LastName);//原型是他爹，他爹姓郑，所以它也姓郑： "郑"
```

写法也可以这么写：

```js
Person.prototype = {
    LastName = "郑",
}
```

##### **constructor(构造器)属性：可手动更改**

用来查看子类的函数体

constructor是prototype对象自带的属性，里面的值为子类的方法体

```js
function A(){
    
}
var a = new A();
console.log(a.constructor);//它会返回a拿到的构造函数的原型
```

##### `__proto__`属性：指向的是一个属性

改它相当于换爹

系统帮我们写的一个隐式属性，他**指向的是我们这个函数的原型(`__proto__`的值为：函数名.prototype)**，当我们访问这个函数里面没有的东西的时候它会去我们`__proto__`里去找我们的原型有没有，如果我们**把它的指向给改了，我们就找不到原型了。而是找到我们改的那个地方了**

![批注 2020-03-24 140916](F:\Typora\笔记图片(勿删)\批注 2020-03-24 140916.jpg)

最准确的来说应该是：var this = Object.create(Person.prototype);

控制台中：person.name = "sunny"

因为我们这个构造函数指向的是第一次prototype指向的那个空间，prototype改了跟它没有任何关系person.name 改的是值 person.prototype = {}这是直接改了地址了，而如果在它创建之前把它的地址给改了那么他也就改了，因为它指向的是Person.prototype

##### 原型链

我们自己添加的`__prototype__`是系统是不会读的

原型链的终端为：object.prototype

你可以拿一个原型指向一个函数，然后这个函数也有原型，我们就可以通过第一个原型访问到第二格原型里面的东西，也就是只要上面有proto就一直往上面找，知道找到object这个祖先，就没有了

JS中的原型和Java一样有一个祖先，object.prototype它里面存放了包装类等它身体里面没有`__proto__`了，就像Java里面的object一样

它的后代无法delete父类的属性，只能delete自己的

如果原型里面有对象，然后我们去修改对象里面的值，我们是通过谁去修改的这个值就属于谁的，如果没有就新建

var obj = {} == var obj1 = new Object();

##### Object.create(原型/null)

它可以改变一个对象指定的最终原型，也就是一般对象的最终原型是Object.prototype，而如果我给一个对象：var obj = Object.create(原型(Object类型的数)/null)，那么我们最终的原型终端就为我们填的原型/null了

填null时里面的Object里面什么都没有

### 19.call/apply

作用：改变this指向

区别：后面传的参数列表不同 

​		call传一个一个形参对应的值，apply传arguments数组

![批注 2020-03-24 160448](F:\Typora\笔记图片(勿删)\批注 2020-03-24 160448.jpg)

![批注 2020-03-24 160509](F:\Typora\笔记图片(勿删)\批注 2020-03-24 160509.jpg)

其实我们执行方法：方法名()   其实实际是：方法名.call()

方法名()和方法名.call()没有任何区别，只是call里的第一个参数会改变this的指向

用法：借别人的方法来给自己加东西

![批注 2020-03-24 165434](F:\Typora\笔记图片(勿删)\批注 2020-03-24 165434.jpg)

### 20.继承

```js
a.prototype.LastName = "Deng";
function A(){
    
}
b.prototype = a.prototype;
function B(){
    
}
//两个原型共用一个空间
```

可是我们通常这么写：

```js
function A(){
    
}
function B(){
    
}
function exten(Target继承的, Origin被继承的){
    Target.prototype = Origin.prototype;
}
exten(A, B);//必须得先继承再创建对象不然不会有继承
var a = new A();
```

***圣杯模式**

![批注 2020-03-24 182841](F:\Typora\笔记图片(勿删)\批注 2020-03-24 182841.jpg)

```js
function exten(Target, Origin){
    function F(){}
    F.prototype = Origin.prototype;
    Target.prototype = new F();
    //不过现在的Target的constuctor值为Origin，所以我们要他把给手动改回来以便日后开发
    Target.prototype.constuctor = Target;
    //此时proto指向的类是Object.prototype
    Target.prototype.uber = Origin.prototype;
}
exten(A, B);
var a = new A();
var b = new B();
```

### 21.命名空间

你写的功能的入口变量通常为init人名

**老办法：**

![批注 2020-03-25 141725](F:\Typora\笔记图片(勿删)\批注 2020-03-25 141725.jpg)

![批注 2020-03-25 141741](F:\Typora\笔记图片(勿删)\批注 2020-03-25 141741.jpg)

**一般方法：**

​			闭包

**仿jQuery：**

​			模仿jQuery实现连续调用函数

```js
var deng = {
    smoke : function (){
        console.log('Somking... xuan cool!');
        return this;//因为默认一个函数的返回值为undefined，所以这会导致我们下次调用的时候使用undefined去调用别的函数，那这就会报错了，所以我们将他显示的改为调用这个方法的对象，这样下次我们还是用这个对象来调用，这样就好使了
    }
    drink : function (){
        console.log('drinking... ye cool!');
        return this;
    }
}
deng.smoke().drink();//这样子就可以和jQuery可以连续调用了
```

**将对象和属性拼接：**

obj.name ---> obj['name'] 系统内部其实是这个来进行一个隐式转化的，这样我们就可以进行属性拼接也就是[]里面可以放变量这样就更灵活了

![批注 2020-03-25 145414](F:\Typora\笔记图片(勿删)\批注 2020-03-25 145414.jpg)

### 22.对象的枚举

#### JS中的foreach循环

js中通常用来遍历对象，因为对象没有length

```js
var obj = {
    name : '13',
    age : 12,
    sex : 'male'
}
for(var key in obj){//key是字符串类型的
    console.log(obj.key);//这样写是不行的，系统会变成obj['prop']他就会把它当成属性了
    console.log(obj[key]);//ok因为key的值是string类型的
}
```

结论：我们用对象里面的属性的时候尽量这么写

**hasOwnProperty(属性名string)：**

![批注 2020-03-25 151506](F:\Typora\笔记图片(勿删)\批注 2020-03-25 151506.jpg)

prop只会打印自己设置的属性名，不会成为系统自带的

*对象名.hasOwnProperty(属性名string)：返回这个属性是不是属于这个对象的true/false



**in**

in操作符和hasOwnProperty差不多不过你给他的这个属性只要有它就会返回true不管是父类还是子类的

```js
obj.prototype.width = 200,
var obj = {
    height : 100,
}
'width' in obj//true
```



**instanceof:**

> **看A对象的原型链上有没有B的原型**
>
> **A instanof B**

```js
function A(){
    
}
var a = new A();
//----------------------------控制台中---------------------------------
a instanceof A//true
a instanceof Object//true
```



**toString.call()**

我们可以调整toString方法里面的this指向



**arguments.callee**

指向函数自身引用

作用：

```js
var num = (function (n){
    if(n == 1){
        return 1;
    }
    return n * arguments.callee(n - 1);
})
```

此时的arguments.callee指向的就是我们的立即执行函数这个方法体

### 23.深度克隆

```js
var obj = {//被克隆的对象
                name : "Zheng",
                hobby : ['playbackball', 'palyfootball'],
                wife : {
                    name : "Guan",
                    son : {
                        name : "xiaoZheng"
                    }
                }
            }
            var obj1 = {};//要克隆的对象
            function aLone(Orgin, Target){//克隆函数 参数：被克隆对象 克隆对象
                //初始化
                Target = Target || {},//防止如果没有传参数而报错
                    toStr = Object.prototype.toString,
                    arrObj = "[object Array]";
                for(var prop in Orgin){
                    if(Orgin.hasOwnProperty(prop)){
                        if(typeof(Orgin[prop]) == "object" && Orgin[prop] !== null){
                            Target[prop] = (toStr.call(Orgin[prop])) == (arrObj) ? [] : {};//利用三目运算符判断它是否是数组类型 是：[] 否：{}
                            aLone(Orgin[prop], Target[prop]);//形成递归
                        }else{
                            Target[prop] = Orgin[prop];//如果全为原始值，则执行完foreach退出这个函数，形成一个出口
                        }
                    }
                }
                return Target;//如果用户没有提供对象参数那么我们自己创建的对象克隆完得返回回去
            }
```



### 24.创建对象的方式

1.对象字面量

```js
var obj = {};
```

2.系统自带的构造函数

```js
var obj = new Object();
```

3.我们自定义的构造函数

```js
function Fn(){
    this.name = "xxx"
}
var obj = new Fn();
```

4.通过Object.create()

需要有一个创建的原型：`function Fn (){}/{}`，可以把create看成是一个复制机，你给他一个模型他能给你复制出一个一模一样的，以这个模型为原型，并不是指向这个模型，所以obj !== `function Fn (){}/{}`

```js
var obj = Object.create(创建对象的原型);
```

### 25.创建数组的方式

Javascriptt中数组基本不会报错，包括数组越界(返回undefined)，JavaScript底层就是对象

1.数组字面量

```js
var arr = [];
```

​	拓展：

​	1.数组里面写,,,也算一位

```js
var arr = [1,2,,,,4,5];
```

2.通过系统自带的构造函数创建数组

```js
var arr = new Array();//如果你只传一个参数，那么代表的就是数组长度，传多个参数为数组内容
//如果传小数则会报错
```

#### 25.1数组常用的方法

改变原数组

​	push,pop,shift,unshift,sort,reverse

​	splice

​	

​	**push:**

​		给数组添加元素

​		返回添加完后数组的长度，返回值类型number

```js
var arr = [];
arr.push(10);//可添加多个
arr.push(1,2,3,4,5);
```

​		自己模仿一个push方法：

```js
Array.prototype.push = function (){//因为不确定我们的用户会传进来多少位数字
                for(var i = 0; i < arguments.length; i++){
                    this[this.length] = arguments[i];//给js中的数组的第length位加元素数组会自动把你的数组长度加1
                }
                return this.length;//模仿js的Array.prototype.push()的返回值
            }
```

​			**pop：**

​			剪掉数组中的第length位

​			传参和不传参一样没有意义

​			在控制台打印数组的原来的长度

​			返回值数组的第length的值

```js
var arr = [1,2,3];
arr.pop();
//arr:1,2
```

​			**shift:**

​			剪掉数组的第一位

​			传参和不传参一样没有意义

​			返回值剪掉的值			

```js
var arr = [1,2,3];
arr.shift();
//arr:2,3
```

​			**unshift:**

​			给数组的最开始位添加元素

​			参数：添加的元素的值 无数个

​			返回添加后的数组的长度

```js
var arr = [3];
arr.unshift(1,2);
//arr:1,2,3
```

​			**reverse:**

​			将数组的内容倒过来

​			返回：倒过来后的数组

```js
var arr = [1,2,3];
arr.reverse();
//arr:3,2,1
```

​			**sort:**

​			他自己的排序方法是用ASCAII码的方式排的，如果我们想按照我们的方式来排那么我们得自己写在他给我们的接口写规则(下面的这个算法也可以直接**return a-b**升序 **return b-a**降序)

![批注 2020-03-27 173104](F:\Typora\笔记图片(勿删)\批注 2020-03-27 173104.jpg)

​			将数组升序

​			返回升序后的数组

```js
var arr = [1,3,2];
arr.sort();
//arr:1,2,3
```

​			**splice:**		

​			如果参数填的是负数那么就倒数:

​			Array.prototype.splice = function (pos){

​					pos += pos >  0 ? 0 : this.length;

​			}

​			返回：截取的片段

​			[|1,2,3,4] 从第|位开始数为第0位

```js
arr.splice(从第几位开始，截取多少的长度，在切口出添加新的数据);//从第三个参数开始都是在切口处添加数据
```



**不可以改变原数组**

concat,join--->split,toString,slice

​		**concat:**

​				作用：将两个数组拼起来

​				返回：一个全新的数组，不影响原来的数组			

```js
var arr1 = [1,2,3];
var arr2 = [4,5,6];
var arr3 = arr1.concat(arr2);
//arr3:1,2,3,4,5,6
```

​		**slice:**

​			与splice类似(截取规则)

​			slice(从该位开始截取，截取到该位)

​				如果只写一个参数的话，它会从这个参数开始一直截取到结束

​				不写就是整个截取

​			作用：截取数组中的设置的截断

​			返回设置的截断，不对原数组进行更改

```js
var arr = [1,2,3];
var newArray = arr.slice(1,2);
//newArray:2
```

​		**join:**

​			参数填写字符串或者原始值最好就是写字符串

​				**不传参则按逗号连接**

​			作用：将数组里面的元素用你所填写的参数进行连接，并以**字符串**的方式**返回**

​				字符串连接最好是用join连接，因为在原始值在栈内存里面存着，栈内存Frist in last out所以我们这样子操作就不好，所以就用我们的join比较好

```js
var arr = [1,2,3];
arr.join("!");
//"1!2!3"
```



​	**字符串：**

​	**split:**

​			作用：按参数给字符串进行拆成数组

```js
var str = "1!2!3";
str.split("!");
//["1","2","3"]
```



​	**toLowerCase():**

​			将字符串转化成小写

### 26.数组和类数组

​	**类数组：**

​			定义：长得像数组可是数组有的方法它全没有

​			关键点：length

​			满足条件：

​					1.属性要为索引(数字)属性，必须有length属性

```js
var obj = {
    "0" : 'a',
    "1" : 'b',
    "length" : 2,
    "push" : Array.prototype.push,
    "splice" : Array.prototype.splice//当对象加上这个属性它在控制台的展示形式就和数组一样的，['a','b']
}
```

### 27.try catch

```js
try{
    console.log('a');
    console.log(a);
    console.log('b');
}catch(e){
    console.log(" " + e.name + ":" + e.message + " ");
}
console.log('c');
//执行结果：ac
```

**在try里面的代码发生错误，不会执行错误后面的try里面的代码**

当**发生错误的时候**它会**返回erro对象里面的error.name        error.message**捕捉发给**参数e**，然后你可以**选择打印它或者不打印**

**他只会返回第一个发生错误的错误信息，因为碰到错误就停了**

#### 27.1Error.name的六种值对应的信息:

1.EvalError : eval()的使用与定义不一致

2.RangeError：数值越界

3.ReferenceError：非法或不能识别的引用数值

4.SyntaxError：发生语法解析错误

5.TypeError：操作数类型错误

6.URIError：URI处理函数使用不当

#### 28.现代浏览器的ES标准

基于es3.0 + **es5.0的新增方法**

如果es3.0和es5.0的语法出现冲突，那么用的是es3.0的，因为它支持的只是二是es5.0的新增方法

#### 28.1 ES5.0严格模式

如果启用了es5.0的严格模式 那么es3.0和es5.0产生冲突的部分就是用es5.0否则会用es3.0

![批注 2020-03-29 230443](F:\Typora\笔记图片(勿删)\批注 2020-03-29 230443.jpg)

**如何启用es5.0的严格模式**

必须得是在**所有js代码的上面**，**不然严格模式无效**

**或者是函数里面的最顶端**：**这个函数是es5.0的严格模式**，其他的区域**没有人管**

```js
"use strict";
```

##### 28.1.1with

![批注 2020-03-30 090439](F:\Typora\笔记图片(勿删)\批注 2020-03-30 090439.jpg)

**with里面的代码**它会**正常执行**，with会把**参数里面的AO**放在**作用域链的最顶端**，也就是**它找作用域链的时候最先找的是with参数里面的AO**，**然后**才是**自己的**，**最后**才是**GO（window）的**

**其实命名空间的用法是拿with来用的**

缺点：

​	减慢执行效率，因为他直接把作用域链给改掉了，如果后期一个作用域链有十几个，那么一改，改十几个所以就会很慢 

##### 28.1.2 eval()

**es3.0都会不能使用eval()， eval 是魔鬼，因为它能改作用域**

它会把字符串里面的东西当代码来执行

```js
var a = 123
eval('console.log(a)');//123
```

